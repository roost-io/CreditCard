// ********RoostGPT********
/*
Test generated by RoostGPT for test CreditCard-Unit using AI Type Claude AI and AI Model claude-3-opus-20240229

ROOST_METHOD_HASH=hashCode_245e974589
ROOST_METHOD_SIG_HASH=hashCode_44411a81c8

Here are some possible JUnit test scenarios for the provided hashCode() method:

Scenario 1: Hash Code Equality for Equal Objects

Details:
  TestName: hashCodeEqualityForEqualObjects()
  Description: This test verifies that the hashCode() method returns the same hash code for two objects with the same cardNumberPartial value.
Execution:
  Arrange: Create two instances of the class with the same cardNumberPartial value.
  Act: Invoke the hashCode() method on both instances.
  Assert: Use assertEquals to verify that the returned hash codes are equal.
Validation:
  The assertion ensures that the hashCode() method adheres to the contract of returning the same hash code for equal objects.
  This test is important to validate the consistency and correctness of the hashCode() implementation.

Scenario 2: Hash Code Inequality for Unequal Objects

Details:
  TestName: hashCodeInequalityForUnequalObjects()
  Description: This test verifies that the hashCode() method returns different hash codes for two objects with different cardNumberPartial values.
Execution:
  Arrange: Create two instances of the class with different cardNumberPartial values.
  Act: Invoke the hashCode() method on both instances.
  Assert: Use assertNotEquals to verify that the returned hash codes are not equal.
Validation:
  The assertion ensures that the hashCode() method generates different hash codes for objects with different cardNumberPartial values.
  This test is crucial to validate that the hashCode() implementation distinguishes between unequal objects.

Scenario 3: Hash Code Consistency

Details:
  TestName: hashCodeConsistency()
  Description: This test verifies that the hashCode() method returns the same hash code for an object across multiple invocations.
Execution:
  Arrange: Create an instance of the class with a specific cardNumberPartial value.
  Act: Invoke the hashCode() method on the instance multiple times.
  Assert: Use assertEquals to verify that the returned hash codes are equal across all invocations.
Validation:
  The assertion ensures that the hashCode() method produces consistent hash codes for the same object.
  This test is important to validate that the hashCode() implementation is stable and deterministic.

Scenario 4: Hash Code for Null cardNumberPartial

Details:
  TestName: hashCodeForNullCardNumberPartial()
  Description: This test verifies the behavior of the hashCode() method when the cardNumberPartial value is null.
Execution:
  Arrange: Create an instance of the class with a null cardNumberPartial value.
  Act: Invoke the hashCode() method on the instance.
  Assert: Use assertEquals to verify that the returned hash code matches the expected value (e.g., 0 or a specific constant).
Validation:
  The assertion ensures that the hashCode() method handles null values correctly and returns the expected hash code.
  This test is important to validate the behavior of the hashCode() implementation in the presence of null values.

These test scenarios cover different aspects of the hashCode() method, including equality, inequality, consistency, and handling of null values. They aim to validate the correctness and adherence to the hashCode() contract.
*/

// ********RoostGPT********
package org.openapitools.model;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.net.URI;
import java.util.Objects;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import org.openapitools.jackson.nullable.JsonNullable;
import java.time.OffsetDateTime;
import javax.validation.Valid;
import javax.validation.constraints.*;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.*;
import javax.annotation.Generated;

class GetCardDetails200ResponseHashCodeTest {

	@Test
	void hashCodeEqualityForEqualObjects() {
		GetCardDetails200Response response1 = new GetCardDetails200Response();
		response1.setCardNumberPartial("1234");
		GetCardDetails200Response response2 = new GetCardDetails200Response();
		response2.setCardNumberPartial("1234");
		int hashCode1 = response1.hashCode();
		int hashCode2 = response2.hashCode();
		assertEquals(hashCode1, hashCode2);
	}

	@Test
	void hashCodeInequalityForUnequalObjects() {
		GetCardDetails200Response response1 = new GetCardDetails200Response();
		response1.setCardNumberPartial("1234");
		GetCardDetails200Response response2 = new GetCardDetails200Response();
		response2.setCardNumberPartial("5678");
		int hashCode1 = response1.hashCode();
		int hashCode2 = response2.hashCode();
		assertNotEquals(hashCode1, hashCode2);
	}

	@Test
	void hashCodeConsistency() {
		GetCardDetails200Response response = new GetCardDetails200Response();
		response.setCardNumberPartial("1234");
		int hashCode1 = response.hashCode();
		int hashCode2 = response.hashCode();
		int hashCode3 = response.hashCode();
		assertEquals(hashCode1, hashCode2);
		assertEquals(hashCode2, hashCode3);
	}

	@Test
	void hashCodeForNullCardNumberPartial() {
		GetCardDetails200Response response = new GetCardDetails200Response();
		response.setCardNumberPartial(null);
		int hashCode = response.hashCode();

		// Modify the expected hash code based on the actual implementation
		// If Objects.hash(null) returns 0, then use:
		// assertEquals(0, hashCode);
		// If Objects.hash(null) returns a non-zero value, then use that value
		assertEquals(Objects.hash((Object) null), hashCode);
	}

}
