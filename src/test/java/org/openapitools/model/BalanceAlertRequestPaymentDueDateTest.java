// ********RoostGPT********
/*
Test generated by RoostGPT for test CreditCard-Unit using AI Type Claude AI and AI Model claude-3-opus-20240229

ROOST_METHOD_HASH=paymentDueDate_ede8a708e5
ROOST_METHOD_SIG_HASH=paymentDueDate_2c21b6ecde

Here are the JUnit test scenarios for the provided paymentDueDate method:

Scenario 1: Valid Payment Due Date

Details:
  TestName: paymentDueDateWithValidDate
  Description: This test verifies that the paymentDueDate method sets the paymentDueDate field correctly when a valid LocalDate is provided.
Execution:
  Arrange: Create an instance of the BalanceAlertRequest class.
  Act: Invoke the paymentDueDate method with a valid LocalDate value.
  Assert: Use assertEquals to verify that the paymentDueDate field is set to the provided value.
Validation:
  The assertion ensures that the paymentDueDate field is properly set when a valid date is passed to the method.
  This test is important to validate that the method behaves as expected for valid input.

Scenario 2: Null Payment Due Date

Details:
  TestName: paymentDueDateWithNullDate
  Description: This test checks the behavior of the paymentDueDate method when a null value is passed as the paymentDueDate.
Execution:
  Arrange: Create an instance of the BalanceAlertRequest class.
  Act: Invoke the paymentDueDate method with a null value.
  Assert: Use assertNull to verify that the paymentDueDate field remains null.
Validation:
  The assertion confirms that the method handles null input gracefully and does not modify the paymentDueDate field.
  This test is crucial to ensure that the method does not throw exceptions or set invalid values when given null input.

Scenario 3: Payment Due Date Before Current Date

Details:
  TestName: paymentDueDateBeforeCurrentDate
  Description: This test verifies the behavior of the paymentDueDate method when the provided paymentDueDate is before the currentDate.
Execution:
  Arrange: Create an instance of the BalanceAlertRequest class and set the currentDate field to a specific LocalDate value.
  Act: Invoke the paymentDueDate method with a LocalDate value that is before the currentDate.
  Assert: Use assertTrue to verify that the paymentDueDate is set correctly and is before the currentDate.
Validation:
  The assertion ensures that the method allows setting a paymentDueDate that is before the currentDate.
  This test validates that the method does not impose any restrictions on the paymentDueDate being before the currentDate.

Scenario 4: Payment Due Date After Current Date

Details:
  TestName: paymentDueDateAfterCurrentDate
  Description: This test checks the behavior of the paymentDueDate method when the provided paymentDueDate is after the currentDate.
Execution:
  Arrange: Create an instance of the BalanceAlertRequest class and set the currentDate field to a specific LocalDate value.
  Act: Invoke the paymentDueDate method with a LocalDate value that is after the currentDate.
  Assert: Use assertTrue to verify that the paymentDueDate is set correctly and is after the currentDate.
Validation:
  The assertion confirms that the method allows setting a paymentDueDate that is after the currentDate.
  This test validates that the method does not impose any restrictions on the paymentDueDate being after the currentDate.

Scenario 5: Chaining Multiple Calls to paymentDueDate

Details:
  TestName: chainingMultiplePaymentDueDates
  Description: This test verifies that multiple calls to the paymentDueDate method can be chained together and the last provided value is set correctly.
Execution:
  Arrange: Create an instance of the BalanceAlertRequest class.
  Act: Chain multiple calls to the paymentDueDate method with different LocalDate values.
  Assert: Use assertEquals to verify that the paymentDueDate field is set to the last provided value.
Validation:
  The assertion ensures that the method allows chaining multiple calls and sets the paymentDueDate to the last provided value.
  This test validates that the method returns the BalanceAlertRequest instance correctly, enabling method chaining.

Note: The provided test scenarios assume the existence of necessary constructors, getters, and setters for the BalanceAlertRequest class and its fields.
*/

// ********RoostGPT********
package org.openapitools.model;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;
import java.time.LocalDate;
import java.util.stream.Stream;
import static org.junit.jupiter.api.Assertions.*;
import java.net.URI;
import java.util.Objects;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import org.springframework.format.annotation.DateTimeFormat;
import org.openapitools.jackson.nullable.JsonNullable;
import java.time.OffsetDateTime;
import javax.validation.Valid;
import javax.validation.constraints.*;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.*;
import javax.annotation.Generated;

class BalanceAlertRequestPaymentDueDateTest {

	private BalanceAlertRequest balanceAlertRequest;

	@BeforeEach
	void setUp() {
		balanceAlertRequest = new BalanceAlertRequest();
	}

	@Test
	void paymentDueDateWithValidDate() {
		LocalDate validDate = LocalDate.of(2023, 6, 10);
		balanceAlertRequest.paymentDueDate(validDate);
		assertEquals(validDate, balanceAlertRequest.getPaymentDueDate());
	}

	@Test
	void paymentDueDateWithNullDate() {
		balanceAlertRequest.paymentDueDate(null);
		assertNull(balanceAlertRequest.getPaymentDueDate());
	}

	@Test
	void paymentDueDateBeforeCurrentDate() {
		LocalDate currentDate = LocalDate.of(2023, 6, 15);
		LocalDate paymentDueDate = LocalDate.of(2023, 6, 10);
		balanceAlertRequest.setCurrentDate(currentDate);
		balanceAlertRequest.paymentDueDate(paymentDueDate);
		assertTrue(balanceAlertRequest.getPaymentDueDate().isBefore(balanceAlertRequest.getCurrentDate()));
	}

	@Test
	void paymentDueDateAfterCurrentDate() {
		LocalDate currentDate = LocalDate.of(2023, 6, 10);
		LocalDate paymentDueDate = LocalDate.of(2023, 6, 15);
		balanceAlertRequest.setCurrentDate(currentDate);
		balanceAlertRequest.paymentDueDate(paymentDueDate);
		assertTrue(balanceAlertRequest.getPaymentDueDate().isAfter(balanceAlertRequest.getCurrentDate()));
	}

	@Test
	void chainingMultiplePaymentDueDates() {
		LocalDate paymentDueDate1 = LocalDate.of(2023, 6, 10);
		LocalDate paymentDueDate2 = LocalDate.of(2023, 6, 15);
		LocalDate paymentDueDate3 = LocalDate.of(2023, 6, 20);
		balanceAlertRequest.paymentDueDate(paymentDueDate1)
			.paymentDueDate(paymentDueDate2)
			.paymentDueDate(paymentDueDate3);
		assertEquals(paymentDueDate3, balanceAlertRequest.getPaymentDueDate());
	}

	@ParameterizedTest
	@MethodSource("validPaymentDueDateProvider")
	void paymentDueDateWithValidDateParameterized(LocalDate validDate) {
		balanceAlertRequest.paymentDueDate(validDate);
		assertEquals(validDate, balanceAlertRequest.getPaymentDueDate());
	}

	static Stream<LocalDate> validPaymentDueDateProvider() {
		return Stream.of(LocalDate.of(2023, 6, 10), LocalDate.of(2023, 7, 15), LocalDate.of(2023, 8, 20));
	}

}