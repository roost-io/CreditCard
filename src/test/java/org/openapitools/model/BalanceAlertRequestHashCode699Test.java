// ********RoostGPT********
/*
Test generated by RoostGPT for test CreditCard-Unit using AI Type Claude AI and AI Model claude-3-opus-20240229

ROOST_METHOD_HASH=hashCode_b9a44f8c3f
ROOST_METHOD_SIG_HASH=hashCode_5a2657087a

Here are the JUnit test scenarios for the provided `hashCode` method:

Scenario 1: Verify hashCode for objects with same field values

Details:
  TestName: hashCodeEqualForSameFieldValues
  Description: This test verifies that the hashCode method generates the same hash code for two objects with identical field values (paymentDueDate, currentDate, cardLast4).
Execution:
  Arrange: Create two objects of the class with the same values for paymentDueDate, currentDate, and cardLast4.
  Act: Invoke the hashCode method on both objects.
  Assert: Use assertEquals to verify that the hash codes returned by both objects are equal.
Validation:
  The assertion ensures that the hashCode method adheres to the contract of generating the same hash code for objects with equal field values.
  This test is important to validate the consistency and correctness of the hashCode implementation, which is crucial for using objects in hash-based collections and equality comparisons.

Scenario 2: Verify hashCode for objects with different field values

Details:
  TestName: hashCodeDifferentForDifferentFieldValues
  Description: This test verifies that the hashCode method generates different hash codes for objects with different field values (paymentDueDate, currentDate, cardLast4).
Execution:
  Arrange: Create two objects of the class with different values for at least one of the fields (paymentDueDate, currentDate, or cardLast4).
  Act: Invoke the hashCode method on both objects.
  Assert: Use assertNotEquals to verify that the hash codes returned by both objects are not equal.
Validation:
  The assertion ensures that the hashCode method generates different hash codes for objects with different field values.
  This test is important to validate that the hashCode implementation distinguishes between objects with different field values, reducing the chances of hash collisions in hash-based collections.

Scenario 3: Verify hashCode for objects with null field values

Details:
  TestName: hashCodeWithNullFieldValues
  Description: This test verifies that the hashCode method handles null field values correctly and generates consistent hash codes.
Execution:
  Arrange: Create an object of the class with null values for paymentDueDate, currentDate, and cardLast4.
  Act: Invoke the hashCode method on the object.
  Assert: Use assertEquals to verify that the hash code returned by the object matches the expected hash code calculated using Objects.hash with null values.
Validation:
  The assertion ensures that the hashCode method handles null field values correctly and generates the expected hash code.
  This test is important to validate that the hashCode implementation is robust and handles null values gracefully, avoiding null pointer exceptions and ensuring consistent behavior.

Scenario 4: Verify hashCode for objects with boundary field values

Details:
  TestName: hashCodeWithBoundaryFieldValues
  Description: This test verifies that the hashCode method generates consistent hash codes for objects with boundary field values, such as minimum and maximum dates for paymentDueDate and currentDate, and edge cases for cardLast4.
Execution:
  Arrange: Create objects of the class with boundary values for paymentDueDate (e.g., LocalDate.MIN, LocalDate.MAX), currentDate (e.g., LocalDate.MIN, LocalDate.MAX), and cardLast4 (e.g., empty string, maximum length string).
  Act: Invoke the hashCode method on each object.
  Assert: Use assertEquals to verify that the hash codes returned by the objects match the expected hash codes calculated using Objects.hash with the corresponding boundary values.
Validation:
  The assertion ensures that the hashCode method handles boundary field values correctly and generates the expected hash codes.
  This test is important to validate that the hashCode implementation is robust and handles edge cases and boundary values correctly, ensuring consistent behavior across different scenarios.

These test scenarios cover different aspects of the `hashCode` method, including equality of hash codes for objects with the same field values, difference in hash codes for objects with different field values, handling of null field values, and behavior with boundary field values. They help ensure the correctness and consistency of the `hashCode` implementation.
*/

// ********RoostGPT********
package org.openapitools.model;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import java.time.LocalDate;
import java.util.stream.Stream;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import java.net.URI;
import java.util.Objects;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import org.springframework.format.annotation.DateTimeFormat;
import org.openapitools.jackson.nullable.JsonNullable;
import java.time.OffsetDateTime;
import javax.validation.Valid;
import javax.validation.constraints.*;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.*;
import javax.annotation.Generated;

class BalanceAlertRequestHashCode699Test {
    @Test
    void hashCodeEqualForSameFieldValues() {
        // Arrange
        LocalDate paymentDueDate = LocalDate.of(2023, 6, 15);
        LocalDate currentDate = LocalDate.of(2023, 6, 10);
        String cardLast4 = "1234";
        BalanceAlertRequest request1 = new BalanceAlertRequest()
                .paymentDueDate(paymentDueDate)
                .currentDate(currentDate)
                .cardLast4(cardLast4);
        BalanceAlertRequest request2 = new BalanceAlertRequest()
                .paymentDueDate(paymentDueDate)
                .currentDate(currentDate)
                .cardLast4(cardLast4);
        // Act
        int hashCode1 = request1.hashCode();
        int hashCode2 = request2.hashCode();
        // Assert
        assertEquals(hashCode1, hashCode2);
    }
    @Test
    void hashCodeDifferentForDifferentFieldValues() {
        // Arrange
        LocalDate paymentDueDate1 = LocalDate.of(2023, 6, 15);
        LocalDate currentDate1 = LocalDate.of(2023, 6, 10);
        String cardLast4_1 = "1234";
        BalanceAlertRequest request1 = new BalanceAlertRequest()
                .paymentDueDate(paymentDueDate1)
                .currentDate(currentDate1)
                .cardLast4(cardLast4_1);
        LocalDate paymentDueDate2 = LocalDate.of(2023, 7, 15);
        LocalDate currentDate2 = LocalDate.of(2023, 7, 10);
        String cardLast4_2 = "5678";
        BalanceAlertRequest request2 = new BalanceAlertRequest()
                .paymentDueDate(paymentDueDate2)
                .currentDate(currentDate2)
                .cardLast4(cardLast4_2);
        // Act
        int hashCode1 = request1.hashCode();
        int hashCode2 = request2.hashCode();
        // Assert
        assertNotEquals(hashCode1, hashCode2);
    }
    @Test
    void hashCodeWithNullFieldValues() {
        // Arrange
        BalanceAlertRequest request = new BalanceAlertRequest()
                .paymentDueDate(null)
                .currentDate(null)
                .cardLast4(null);
        // Act
        int actualHashCode = request.hashCode();
        // Assert
        int expectedHashCode = java.util.Objects.hash(null, null, null);
        assertEquals(expectedHashCode, actualHashCode);
    }
    @ParameterizedTest
    @MethodSource("boundaryFieldValuesProvider")
    void hashCodeWithBoundaryFieldValues(LocalDate paymentDueDate, LocalDate currentDate, String cardLast4) {
        // Arrange
        BalanceAlertRequest request = new BalanceAlertRequest()
                .paymentDueDate(paymentDueDate)
                .currentDate(currentDate)
                .cardLast4(cardLast4);
        // Act
        int actualHashCode = request.hashCode();
        // Assert
        int expectedHashCode = java.util.Objects.hash(paymentDueDate, currentDate, cardLast4);
        assertEquals(expectedHashCode, actualHashCode);
    }
    static Stream<Arguments> boundaryFieldValuesProvider() {
        return Stream.of(
                Arguments.of(LocalDate.MIN, LocalDate.MIN, ""),
                Arguments.of(LocalDate.MAX, LocalDate.MAX, "1234567890")
        );
    }
}