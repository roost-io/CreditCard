// ********RoostGPT********
/*
Test generated by RoostGPT for test CreditCard-Unit using AI Type Claude AI and AI Model claude-3-opus-20240229

ROOST_METHOD_HASH=currentDate_a57647b643
ROOST_METHOD_SIG_HASH=currentDate_78774936c5

Here are the test scenarios for the provided `currentDate` method:

Scenario 1: Setting a valid current date

Details:
  TestName: currentDateWithValidDate
  Description: This test verifies that the `currentDate` method sets the `currentDate` field correctly when a valid `LocalDate` is provided.
Execution:
  Arrange: Create an instance of the `BalanceAlertRequest` class.
  Act: Call the `currentDate` method with a valid `LocalDate` object.
  Assert: Use `assertEquals` to verify that the `currentDate` field of the `BalanceAlertRequest` instance is equal to the provided `LocalDate`.
Validation:
  The assertion ensures that the `currentDate` field is set correctly when a valid date is provided.
  This test is important to validate that the `currentDate` method behaves as expected and correctly sets the `currentDate` field.

Scenario 2: Setting a null current date

Details:
  TestName: currentDateWithNullDate
  Description: This test verifies that the `currentDate` method handles setting a null `currentDate` field correctly.
Execution:
  Arrange: Create an instance of the `BalanceAlertRequest` class.
  Act: Call the `currentDate` method with a null value.
  Assert: Use `assertNull` to verify that the `currentDate` field of the `BalanceAlertRequest` instance is set to null.
Validation:
  The assertion ensures that the `currentDate` field is set to null when a null value is provided.
  This test is important to validate that the `currentDate` method handles null values gracefully and doesn't throw any exceptions.

Scenario 3: Chaining multiple method calls

Details:
  TestName: currentDateWithMethodChaining
  Description: This test verifies that the `currentDate` method returns the `BalanceAlertRequest` instance, allowing for method chaining.
Execution:
  Arrange: Create an instance of the `BalanceAlertRequest` class.
  Act: Call the `currentDate` method with a valid `LocalDate` object and chain another method call (e.g., `cardLast4`) to the result.
  Assert: Use `assertEquals` to verify that the `currentDate` and `cardLast4` fields of the `BalanceAlertRequest` instance are set correctly.
Validation:
  The assertion ensures that the `currentDate` method returns the `BalanceAlertRequest` instance, enabling method chaining.
  This test is important to validate that the `currentDate` method supports fluent API style and allows for convenient method chaining.

Scenario 4: Setting current date after payment due date

Details:
  TestName: currentDateAfterPaymentDueDate
  Description: This test verifies that the `currentDate` method allows setting a current date that is after the `paymentDueDate`.
Execution:
  Arrange: Create an instance of the `BalanceAlertRequest` class and set the `paymentDueDate` field to a specific date.
  Act: Call the `currentDate` method with a `LocalDate` that is after the `paymentDueDate`.
  Assert: Use `assertEquals` to verify that the `currentDate` field of the `BalanceAlertRequest` instance is set correctly.
Validation:
  The assertion ensures that the `currentDate` method allows setting a current date that is after the `paymentDueDate`.
  This test is important to validate that the `currentDate` method does not enforce any date range restrictions and allows flexibility in setting the current date.

These test scenarios cover different aspects of the `currentDate` method, including setting valid and null dates, method chaining, and date range scenarios. They ensure that the method behaves as expected and handles various input scenarios correctly.
*/

// ********RoostGPT********
package org.openapitools.model;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import static org.junit.jupiter.api.Assertions.*;
import java.time.LocalDate;
import java.net.URI;
import java.util.Objects;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import org.springframework.format.annotation.DateTimeFormat;
import org.openapitools.jackson.nullable.JsonNullable;
import java.time.OffsetDateTime;
import javax.validation.Valid;
import javax.validation.constraints.*;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.*;
import javax.annotation.Generated;

class BalanceAlertRequestCurrentDateTest {

	private BalanceAlertRequest balanceAlertRequest;

	@BeforeEach
	void setUp() {
		balanceAlertRequest = new BalanceAlertRequest();
	}

	@Test
	void currentDateWithValidDate() {
		LocalDate validDate = LocalDate.of(2023, 6, 10);
		balanceAlertRequest.currentDate(validDate);
		assertEquals(validDate, balanceAlertRequest.getCurrentDate());
	}

	@Test
	void currentDateWithNullDate() {
		balanceAlertRequest.currentDate(null);
		assertNull(balanceAlertRequest.getCurrentDate());
	}

	@Test
	void currentDateWithMethodChaining() {
		LocalDate validDate = LocalDate.of(2023, 6, 10);
		String cardLast4 = "1234";
		balanceAlertRequest.currentDate(validDate).cardLast4(cardLast4);
		assertEquals(validDate, balanceAlertRequest.getCurrentDate());
		assertEquals(cardLast4, balanceAlertRequest.getCardLast4());
	}

	@Test
	void currentDateAfterPaymentDueDate() {
		LocalDate paymentDueDate = LocalDate.of(2023, 6, 5);
		LocalDate currentDate = LocalDate.of(2023, 6, 10);
		balanceAlertRequest.paymentDueDate(paymentDueDate);
		balanceAlertRequest.currentDate(currentDate);
		assertEquals(currentDate, balanceAlertRequest.getCurrentDate());
	}

}