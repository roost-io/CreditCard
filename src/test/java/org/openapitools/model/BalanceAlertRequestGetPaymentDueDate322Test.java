// ********RoostGPT********
/*
Test generated by RoostGPT for test CreditCard-Unit using AI Type Claude AI and AI Model claude-3-opus-20240229

ROOST_METHOD_HASH=getPaymentDueDate_915156d673
ROOST_METHOD_SIG_HASH=getPaymentDueDate_01dab947d7

Here are the JUnit test scenarios for the provided `getPaymentDueDate` method:

Scenario 1: Verify payment due date retrieval

Details:
  TestName: paymentDueDateRetrieval()
  Description: This test verifies that the `getPaymentDueDate` method correctly retrieves the payment due date stored in the object.
Execution:
  Arrange: Create an instance of the class containing the `getPaymentDueDate` method and set a specific payment due date.
  Act: Invoke the `getPaymentDueDate` method on the created instance.
  Assert: Use `assertEquals` to compare the retrieved payment due date with the expected date.
Validation:
  The assertion verifies that the `getPaymentDueDate` method returns the correct payment due date that was set during object creation or through a setter method.
  This test ensures that the payment due date retrieval functionality works as expected, which is crucial for accurate billing and payment processing in the application.

Scenario 2: Verify default payment due date

Details:
  TestName: defaultPaymentDueDate()
  Description: This test verifies that the `getPaymentDueDate` method returns the default payment due date when no specific date is set.
Execution:
  Arrange: Create an instance of the class containing the `getPaymentDueDate` method without setting a payment due date.
  Act: Invoke the `getPaymentDueDate` method on the created instance.
  Assert: Use `assertEquals` to compare the retrieved payment due date with the expected default date (e.g., null or a predefined default date).
Validation:
  The assertion verifies that the `getPaymentDueDate` method returns the expected default payment due date when no specific date is set.
  This test ensures that the application handles cases where the payment due date is not explicitly set, providing a default behavior to avoid null pointer exceptions or unexpected results.

Scenario 3: Verify payment due date immutability

Details:
  TestName: paymentDueDateImmutability()
  Description: This test verifies that the `getPaymentDueDate` method returns an immutable `LocalDate` object to prevent accidental modifications.
Execution:
  Arrange: Create an instance of the class containing the `getPaymentDueDate` method and set a specific payment due date.
  Act: Invoke the `getPaymentDueDate` method on the created instance and attempt to modify the returned `LocalDate` object.
  Assert: Use `assertEquals` to compare the original payment due date with the retrieved date after the modification attempt.
Validation:
  The assertion verifies that the `getPaymentDueDate` method returns an immutable `LocalDate` object, preventing any modifications to the original payment due date.
  This test ensures that the payment due date remains unchanged even if the returned object is inadvertently modified, maintaining data integrity and avoiding unexpected behavior in the application.

These test scenarios cover the basic functionality of the `getPaymentDueDate` method, including retrieval of the payment due date, handling of default values, and ensuring immutability of the returned `LocalDate` object. Additional test scenarios can be added based on specific requirements and edge cases related to the payment due date in the application.
*/

// ********RoostGPT********
package org.openapitools.model;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import java.time.LocalDate;
import java.util.stream.Stream;
import static org.junit.jupiter.api.Assertions.*;
import java.net.URI;
import java.util.Objects;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import org.springframework.format.annotation.DateTimeFormat;
import org.openapitools.jackson.nullable.JsonNullable;
import java.time.OffsetDateTime;
import javax.validation.Valid;
import javax.validation.constraints.*;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.*;
import javax.annotation.Generated;

class BalanceAlertRequestGetPaymentDueDate322Test {
    private BalanceAlertRequest balanceAlertRequest;
    @BeforeEach
    void setUp() {
        balanceAlertRequest = new BalanceAlertRequest();
    }
    @Test
    void paymentDueDateRetrieval() {
        // Arrange
        LocalDate expectedDate = LocalDate.of(2023, 6, 30);
        balanceAlertRequest.setPaymentDueDate(expectedDate);
        // Act
        LocalDate actualDate = balanceAlertRequest.getPaymentDueDate();
        // Assert
        assertEquals(expectedDate, actualDate);
    }
    @Test
    void defaultPaymentDueDate() {
        // Arrange
        // No payment due date set
        // Act
        LocalDate actualDate = balanceAlertRequest.getPaymentDueDate();
        // Assert
        assertNull(actualDate);
    }
    @Test
    void paymentDueDateImmutability() {
        // Arrange
        LocalDate originalDate = LocalDate.of(2023, 6, 30);
        balanceAlertRequest.setPaymentDueDate(originalDate);
        // Act
        LocalDate retrievedDate = balanceAlertRequest.getPaymentDueDate();
        retrievedDate = retrievedDate.plusDays(1); // Attempt to modify the retrieved date
        // Assert
        assertEquals(originalDate, balanceAlertRequest.getPaymentDueDate());
    }
    @ParameterizedTest
    @MethodSource("provideDatesForPaymentDueDate")
    void paymentDueDateParameterizedTest(LocalDate inputDate, LocalDate expectedDate) {
        // Arrange
        balanceAlertRequest.setPaymentDueDate(inputDate);
        // Act
        LocalDate actualDate = balanceAlertRequest.getPaymentDueDate();
        // Assert
        assertEquals(expectedDate, actualDate);
    }
    private static Stream<Arguments> provideDatesForPaymentDueDate() {
        return Stream.of(
                Arguments.of(LocalDate.of(2023, 6, 30), LocalDate.of(2023, 6, 30)),
                Arguments.of(LocalDate.of(2024, 12, 31), LocalDate.of(2024, 12, 31)),
                Arguments.of(null, null)
        );
    }
}