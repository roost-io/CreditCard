// ********RoostGPT********
/*
Test generated by RoostGPT for test CreditCard-Unit using AI Type Claude AI and AI Model claude-3-opus-20240229

ROOST_METHOD_HASH=hashCode_583bda255d
ROOST_METHOD_SIG_HASH=hashCode_44411a81c8

Here are some JUnit test scenarios for the provided hashCode() method:

Scenario 1: Test hashCode with all fields set

Details:
  TestName: hashCodeWithAllFieldsSet
  Description: This test verifies that the hashCode method returns the expected hash code when all fields (paymentDueDate, currentDate, cardLast4) are set to non-null values.
Execution:
  Arrange: Create an instance of the class and set all fields to valid non-null values.
  Act: Invoke the hashCode method on the instance.
  Assert: Use JUnit assertions to compare the returned hash code with the expected hash code calculated using Objects.hash(paymentDueDate, currentDate, cardLast4).
Validation:
  The assertion verifies that the hashCode method correctly calculates the hash code based on the values of all fields. This test ensures that the hashCode implementation is consistent with the equals method and follows the hashCode contract.

Scenario 2: Test hashCode with null fields

Details:
  TestName: hashCodeWithNullFields
  Description: This test checks the behavior of the hashCode method when one or more fields (paymentDueDate, currentDate, cardLast4) are set to null.
Execution:
  Arrange: Create an instance of the class and set one or more fields to null.
  Act: Invoke the hashCode method on the instance.
  Assert: Use JUnit assertions to compare the returned hash code with the expected hash code calculated using Objects.hash(null, currentDate, cardLast4) or similar combinations.
Validation:
  The assertion verifies that the hashCode method handles null field values correctly and returns the expected hash code. This test ensures that the hashCode implementation is robust and can handle null values without throwing exceptions.

Scenario 3: Test hashCode with equal objects

Details:
  TestName: hashCodeWithEqualObjects
  Description: This test verifies that the hashCode method returns the same hash code for two objects that are considered equal according to the equals method.
Execution:
  Arrange: Create two instances of the class with the same field values.
  Act: Invoke the hashCode method on both instances.
  Assert: Use JUnit assertions to compare the hash codes returned by both instances and ensure they are equal.
Validation:
  The assertion verifies that the hashCode method follows the contract of returning the same hash code for equal objects. This test ensures that the hashCode implementation is consistent with the equals method and enables proper functioning of hash-based collections.

Scenario 4: Test hashCode with different field values

Details:
  TestName: hashCodeWithDifferentFieldValues
  Description: This test checks that the hashCode method returns different hash codes for objects with different field values.
Execution:
  Arrange: Create multiple instances of the class with different combinations of field values.
  Act: Invoke the hashCode method on each instance.
  Assert: Use JUnit assertions to compare the hash codes returned by the instances and ensure they are different.
Validation:
  The assertion verifies that the hashCode method generates different hash codes for objects with different field values. This test ensures that the hashCode implementation provides a good distribution of hash codes and minimizes collisions.

These test scenarios cover different aspects of the hashCode method, including handling of null values, consistency with the equals method, and generation of distinct hash codes for different objects. They help ensure the correctness and reliability of the hashCode implementation in the given class.
*/

// ********RoostGPT********
package org.openapitools.model;

import java.time.LocalDate;
import java.util.Objects;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.net.URI;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import org.springframework.format.annotation.DateTimeFormat;
import org.openapitools.jackson.nullable.JsonNullable;
import java.time.OffsetDateTime;
import javax.validation.Valid;
import javax.validation.constraints.*;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.*;
import javax.annotation.Generated;

class BalanceAlertRequestHashCodeTest {

	@Test
	void hashCodeWithAllFieldsSet() {
		// Arrange
		LocalDate paymentDueDate = LocalDate.of(2023, 6, 15);
		LocalDate currentDate = LocalDate.of(2023, 6, 10);
		String cardLast4 = "1234";
		BalanceAlertRequest request = new BalanceAlertRequest(paymentDueDate, currentDate, cardLast4);
		// Act
		int hashCode = request.hashCode();
		// Assert
		int expectedHashCode = Objects.hash(paymentDueDate, currentDate, cardLast4);
		assertEquals(expectedHashCode, hashCode);
	}

	@Test
	void hashCodeWithNullFields() {
		// Arrange
		LocalDate currentDate = LocalDate.of(2023, 6, 10);
		String cardLast4 = "1234";
		BalanceAlertRequest request = new BalanceAlertRequest(null, currentDate, cardLast4);
		// Act
		int hashCode = request.hashCode();
		// Assert
		int expectedHashCode = Objects.hash(null, currentDate, cardLast4);
		assertEquals(expectedHashCode, hashCode);
	}

	@Test
	void hashCodeWithEqualObjects() {
		// Arrange
		LocalDate paymentDueDate = LocalDate.of(2023, 6, 15);
		LocalDate currentDate = LocalDate.of(2023, 6, 10);
		String cardLast4 = "1234";
		BalanceAlertRequest request1 = new BalanceAlertRequest(paymentDueDate, currentDate, cardLast4);
		BalanceAlertRequest request2 = new BalanceAlertRequest(paymentDueDate, currentDate, cardLast4);
		// Act
		int hashCode1 = request1.hashCode();
		int hashCode2 = request2.hashCode();
		// Assert
		assertEquals(hashCode1, hashCode2);
	}

	@Test
	void hashCodeWithDifferentFieldValues() {
		// Arrange
		LocalDate paymentDueDate1 = LocalDate.of(2023, 6, 15);
		LocalDate currentDate1 = LocalDate.of(2023, 6, 10);
		String cardLast4_1 = "1234";
		BalanceAlertRequest request1 = new BalanceAlertRequest(paymentDueDate1, currentDate1, cardLast4_1);
		LocalDate paymentDueDate2 = LocalDate.of(2023, 7, 15);
		LocalDate currentDate2 = LocalDate.of(2023, 7, 10);
		String cardLast4_2 = "5678";
		BalanceAlertRequest request2 = new BalanceAlertRequest(paymentDueDate2, currentDate2, cardLast4_2);
		// Act
		int hashCode1 = request1.hashCode();
		int hashCode2 = request2.hashCode();
		// Assert
		assertNotEquals(hashCode1, hashCode2);
	}

}