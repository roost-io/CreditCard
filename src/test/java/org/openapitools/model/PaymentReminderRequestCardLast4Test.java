
// ********RoostGPT********
/*
Test generated by RoostGPT for test jira-id_clone using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=cardLast4_9795b5463c
ROOST_METHOD_SIG_HASH=cardLast4_d5160ef920


Scenario 1: Valid Input for CardLast4

Details:
  TestName: validInputForCardLast4
  Description: Ensures that when a valid 4-character string is passed to the `cardLast4` method, the method successfully updates the `cardLast4` field and returns the `PaymentReminderRequest` object.

Execution:
  Arrange: Create a `PaymentReminderRequest` object and prepare a valid 4-character string.
  Act: Invoke the `cardLast4` method with the valid string.
  Assert: Verify that the `cardLast4` field in the object is updated to the passed value and the method returns the same object instance.

Validation:
  Confirms that the method works correctly with a valid input, ensuring the expected functionality to handle proper card number suffix input.

---

Scenario 2: Null Input for CardLast4

Details:
  TestName: nullInputForCardLast4
  Description: Checks the behavior of the `cardLast4` method when a `null` value is passed. It tests whether the field is updated to `null`.

Execution:
  Arrange: Create a `PaymentReminderRequest` object.
  Act: Call the `cardLast4` method with `null`.
  Assert: Verify that the `cardLast4` field is set to `null` after the invocation.

Validation:
  Ensures that the method can handle null inputs gracefully and behaves as expected within application constraints.

---

Scenario 3: Empty String Input for CardLast4

Details:
  TestName: emptyStringInputForCardLast4
  Description: Tests the behavior when an empty string is passed to the `cardLast4` method, verifying whether the field accepts and reflects the empty string.

Execution:
  Arrange: Create a `PaymentReminderRequest` object.
  Act: Invoke `cardLast4` with an empty string (`""`).
  Assert: Ensure the `cardLast4` field is updated to the empty string.

Validation:
  Verifies the system's handling of edge cases where a non-null but empty value is provided for `cardLast4`.

---

Scenario 4: Invalid Input Length (Less Than 4 Characters)

Details:
  TestName: invalidInputLengthLessThan4
  Description: Verifies the behavior when a string with less than 4 characters is provided to the `cardLast4` method.

Execution:
  Arrange: Create a `PaymentReminderRequest` object and use a string (e.g., "123") with fewer than 4 characters as input.
  Act: Invoke `cardLast4` with the short string.
  Assert: Verify that the field is updated with the short value and does not enforce length constraints at this level.

Validation:
  This scenario helps understand the method's limits and whether it enforces constraints directly.

---

Scenario 5: Invalid Input Length (More Than 4 Characters)

Details:
  TestName: invalidInputLengthMoreThan4
  Description: Checks the behavior when a string longer than 4 characters is submitted to the `cardLast4` method.

Execution:
  Arrange: Create a `PaymentReminderRequest` object and use a string with length exceeding 4 characters (e.g., "12345") as input.
  Act: Call `cardLast4` with the long string.
  Assert: Verify that the method accepts the input without enforcing constraints.

Validation:
  Explores whether the method processes inputs that surpass expected constraints and provides insight into any necessary validation.

---

Scenario 6: Special Character Input for CardLast4

Details:
  TestName: specialCharacterInputForCardLast4
  Description: Tests the method with a 4-character string containing special characters (e.g., “!@#$”) to ensure it handles such inputs correctly.

Execution:
  Arrange: Instantiate `PaymentReminderRequest` and prepare a 4-character string with special characters.
  Act: Call `cardLast4` with the special character string.
  Assert: Verify that the `cardLast4` field is updated to the exact string provided.

Validation:
  Confirms that the method can process non-alphanumeric inputs without any unexpected errors or behaviors.

---

Scenario 7: Numeric Input for CardLast4

Details:
  TestName: numericInputForCardLast4
  Description: Tests the method with a valid numeric 4-character string (e.g., “1234”) to ensure it handles purely numeric card number suffix strings.

Execution:
  Arrange: Create a `PaymentReminderRequest` object and prepare a numeric string.
  Act: Call `cardLast4` with the numeric string.
  Assert: Ensure the `cardLast4` field is updated accurately.

Validation:
  Verifies that the method supports numeric inputs, aligning with real-world data where the card suffix is numeric.

---

Scenario 8: Field Persistence Across Multiple Calls

Details:
  TestName: fieldPersistenceAcrossMultipleCalls
  Description: Evaluates the ability of the `cardLast4` method to correctly overwrite previously set values when method is invoked multiple times.

Execution:
  Arrange: Create a `PaymentReminderRequest` object and set an initial value for `cardLast4`. Prepare a second value for update.
  Act: Invoke `cardLast4` method twice using the initial value and then the second value.
  Assert: Verify that the final value in `cardLast4` reflects the last input provided.

Validation:
  Ensures sequential calls to the method consistently update the field and do not retain stale values.

---

Scenario 9: Chained Call for Method Invocation

Details:
  TestName: chainedCallInvocationValidation
  Description: Checks whether the `cardLast4` method can be chained with other methods in `PaymentReminderRequest` for fluent programming.

Execution:
  Arrange: Create a `PaymentReminderRequest` object.
  Act: Invoke `cardLast4` along with other instance methods (`currentDate` or `paymentDueDate`) in a chained fashion.
  Assert: Ensure the `PaymentReminderRequest` object is updated correctly and chaining is supported.

Validation:
  Confirms fluency in the class design, which is critical for usability and developer experience.

*/

// ********RoostGPT********

package org.openapitools.model;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import java.time.LocalDate;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;
import org.junit.jupiter.api.*;
import java.net.URI;
import java.util.Objects;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import org.springframework.format.annotation.DateTimeFormat;
import org.openapitools.jackson.nullable.JsonNullable;
import java.time.OffsetDateTime;
import javax.validation.Valid;
import javax.validation.constraints.*;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.*;
import javax.annotation.Generated;

class PaymentReminderRequestCardLast4Test {

	@Test
	@Tag("valid")
	public void validInputForCardLast4() {
		PaymentReminderRequest request = new PaymentReminderRequest();
		String validCardLast4 = "1234";

		PaymentReminderRequest result = request.cardLast4(validCardLast4);

		assertEquals(validCardLast4, request.getCardLast4());
		assertEquals(request, result);
	}

	@Test
	@Tag("invalid")
	public void nullInputForCardLast4() {
		PaymentReminderRequest request = new PaymentReminderRequest();

		PaymentReminderRequest result = request.cardLast4(null);
		assertNull(request.getCardLast4());
		assertEquals(request, result);
	}

	@Test
	@Tag("boundary")
	public void emptyStringInputForCardLast4() {
		PaymentReminderRequest request = new PaymentReminderRequest();
		String emptyString = "";

		PaymentReminderRequest result = request.cardLast4(emptyString);
		assertEquals(emptyString, request.getCardLast4());
		assertEquals(request, result);
	}

	@Test
	@Tag("invalid")
	public void invalidInputLengthLessThan4() {
		PaymentReminderRequest request = new PaymentReminderRequest();
		String shortCardLast4 = "123"; // TODO: Replace with valid value for production if
										// required

		PaymentReminderRequest result = request.cardLast4(shortCardLast4);
		assertEquals(shortCardLast4, request.getCardLast4());
		assertEquals(request, result);
	}

	@Test
	@Tag("invalid")
	public void invalidInputLengthMoreThan4() {
		PaymentReminderRequest request = new PaymentReminderRequest();
		String longCardLast4 = "12345"; // TODO: Replace with valid value for production
										// if required

		PaymentReminderRequest result = request.cardLast4(longCardLast4);
		assertEquals(longCardLast4, request.getCardLast4());
		assertEquals(request, result);
	}

	@Test
	@Tag("valid")
	public void specialCharacterInputForCardLast4() {
		PaymentReminderRequest request = new PaymentReminderRequest();
		String specialCardLast4 = "!@#$";

		PaymentReminderRequest result = request.cardLast4(specialCardLast4);
		assertEquals(specialCardLast4, request.getCardLast4());
		assertEquals(request, result);
	}

	@Test
	@Tag("valid")
	public void numericInputForCardLast4() {
		PaymentReminderRequest request = new PaymentReminderRequest();
		String numericCardLast4 = "1234";

		PaymentReminderRequest result = request.cardLast4(numericCardLast4);
		assertEquals(numericCardLast4, request.getCardLast4());
		assertEquals(request, result);
	}

	@Test
	@Tag("boundary")
	public void fieldPersistenceAcrossMultipleCalls() {
		PaymentReminderRequest request = new PaymentReminderRequest();
		String firstCardLast4 = "1234";
		String secondCardLast4 = "5678";
		request.cardLast4(firstCardLast4);
		request.cardLast4(secondCardLast4);

		assertEquals(secondCardLast4, request.getCardLast4());
	}

	@Test
	@Tag("integration")
	public void chainedCallInvocationValidation() {
		PaymentReminderRequest request = new PaymentReminderRequest();
		LocalDate currentDate = LocalDate.now();
		LocalDate paymentDueDate = LocalDate.of(2023, 12, 31);
		String cardLast4 = "9876";
		PaymentReminderRequest result = request.currentDate(currentDate)
			.paymentDueDate(paymentDueDate)
			.cardLast4(cardLast4);
		assertEquals(currentDate, result.getCurrentDate());
		assertEquals(paymentDueDate, result.getPaymentDueDate());
		assertEquals(cardLast4, result.getCardLast4());
	}

}