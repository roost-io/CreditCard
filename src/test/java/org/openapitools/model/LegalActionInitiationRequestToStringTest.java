
// ********RoostGPT********
/*
Test generated by RoostGPT for test jira-id_clone using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=toString_33ea57a51c
ROOST_METHOD_SIG_HASH=toString_bbffdadaa2


Scenario 1: Verify toString Generates Properly Formatted String with Null Values

Details:
  TestName: verifyToStringWithNullValues
  Description: Verifies that the `toString` method correctly handles and formats the class fields into a string when all fields are null.

Execution:
  Arrange: Create an instance of `LegalActionInitiationRequest` where all fields (`nonPaymentStatus`, `legalStatus`, `cardLast4`) are left as null by default.
  Act: Call the `toString` method on the instance.
  Assert: Use assertions to verify that the output string contains the expected formatting and values, specifically that all fields are displayed as "null".

Validation:
  Clarify that the `toString` method should correctly display the structure of the class and represent null values when fields are uninitialized. This test ensures the method gracefully handles null values without causing errors and outputs consistent formatting.

*/

// ********RoostGPT********

package org.openapitools.model;

import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import java.net.URI;
import java.util.Objects;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import org.openapitools.jackson.nullable.JsonNullable;
import java.time.OffsetDateTime;
import javax.validation.Valid;
import javax.validation.constraints.*;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.*;
import javax.annotation.Generated;

public class LegalActionInitiationRequestToStringTest {

	@Test
	@Tag("valid")
	public void verifyToStringWithNullValues() {
		// Arrange
		LegalActionInitiationRequest request = new LegalActionInitiationRequest();
		// Act
		String result = request.toString();
		// Assert
		String expected = "class LegalActionInitiationRequest {\n" + "    nonPaymentStatus: null\n"
				+ "    legalStatus: null\n" + "    cardLast4: null\n" + "}";
		assertEquals(expected, result); // Assert that the formatted string is correct
										// with null values.
	}

	@Test
	@Tag("valid")
	public void verifyToStringWithValidValues() {
		// Arrange
		String nonPaymentStatus = "Delinquent";
		String legalStatus = "Escalated";
		String cardLast4 = "1234";
		LegalActionInitiationRequest request = new LegalActionInitiationRequest(nonPaymentStatus, legalStatus,
				cardLast4);
		// Act
		String result = request.toString();
		// Assert
		String expected = "class LegalActionInitiationRequest {\n" + "    nonPaymentStatus: Delinquent\n"
				+ "    legalStatus: Escalated\n" + "    cardLast4: 1234\n" + "}";
		assertEquals(expected, result); // Assert that the formatted string is correct
										// with valid values.
	}

	@Test
	@Tag("invalid")
	public void verifyToStringWithInvalidCardLength() {
		// Arrange
		String nonPaymentStatus = "Delinquent";
		String legalStatus = "Escalated";
		String cardLast4 = "12"; // Invalid card length
		LegalActionInitiationRequest request = new LegalActionInitiationRequest(nonPaymentStatus, legalStatus,
				cardLast4);
		// Act
		String result = request.toString();
		// Assert
		String expected = "class LegalActionInitiationRequest {\n" + "    nonPaymentStatus: Delinquent\n"
				+ "    legalStatus: Escalated\n" + "    cardLast4: 12\n" + "}"; // Assertion
																				// remains
																				// valid
																				// since
																				// length
																				// evaluation
																				// is done
																				// outside
																				// of
																				// formatting.
		assertEquals(expected, result);
	}

	@Test
	@Tag("boundary")
	public void verifyToStringWithBoundaryValues() {
		// Arrange
		String nonPaymentStatus = "A"; // Boundary case: Single character
		String legalStatus = "B"; // Boundary case: Single character
		String cardLast4 = "0000"; // Boundary case: Minimum value in valid card digits
		LegalActionInitiationRequest request = new LegalActionInitiationRequest(nonPaymentStatus, legalStatus,
				cardLast4);
		// Act
		String result = request.toString();
		// Assert
		String expected = "class LegalActionInitiationRequest {\n" + "    nonPaymentStatus: A\n"
				+ "    legalStatus: B\n" + "    cardLast4: 0000\n" + "}";
		assertEquals(expected, result); // Assert that the formatted string is correct
										// with boundary values.
	}

	@Test
	@Tag("integration")
	public void verifyToStringIntegrationTestWithNullAndTrimmedValues() {
		// Arrange
		String nonPaymentStatus = null; // TODO: Change value if you need distinct values
		String legalStatus = " Escalated "; // Intentionally adding trimmed spaces
		String cardLast4 = " 1234 "; // Intentionally adding trimmed spaces
		LegalActionInitiationRequest request = new LegalActionInitiationRequest(nonPaymentStatus, legalStatus.trim(),
				cardLast4.trim());
		// Act
		String result = request.toString();
		// Assert
		String expected = "class LegalActionInitiationRequest {\n" + "    nonPaymentStatus: null\n"
				+ "    legalStatus: Escalated\n" + "    cardLast4: 1234\n" + "}";
		assertEquals(expected, result); // Assert the integration case handles trimming
										// gracefully.
	}

}