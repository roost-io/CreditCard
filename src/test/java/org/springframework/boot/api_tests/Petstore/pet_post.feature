# ********RoostGPT********

# Test generated by RoostGPT for test karate-test-plan using AI Type Azure Open AI and AI Model roostgpt-4-32k
# 
# Feature file generated for /pet_post for http method type POST 
# RoostTestHash=33f954929c
# 
# 

# ********RoostGPT********
Feature: API Tests for Adding a New Pet to the Store

  Background:
    * def urlBase = karate.properties['URL_BASE']
    * url urlBase
    * configure headers = { Authorization: karate.properties['AUTH_TOKEN'] }

  @addPet
  Scenario: Test adding a new pet to the store with valid input
    Given path 'v2/pet'
    And request """ 
      {
        id: 12345,
        category: { id: 1, name: 'Mammals' },
        name: 'doggie',
        photoUrls: [
          'https://example.com/photo1.jpg', 
          'https://example.com/photo2.jpg'
        ],
        tags: [
          { id: 10, name: 'tag1' }, 
          { id: 20, name: 'tag2' }
        ],
        status: 'available'
      }
    """
    When method POST
    Then status 200
    And match response.id == '#number'
    And match response.category.id == '#number'
    And match response.category.name == 'Mammals'
    And match response.name == 'doggie'
    And match response.photoUrls == '#array'
    And match each response.photoUrls[*] == '#string'
    And match response.tags == '#array'
    And match each response.tags[*].id == '#number'
    And match each response.tags[*].name == '#string'
    And match response.status == 'available'

  @addPetInvalid
  Scenario: Test adding a new pet with invalid body
    Given path 'v2/pet'
    And request """ 
      {
        id: 'invalid_id',
        category: { id: 'string_instead_of_number', name: 999 },
        status: 'unknown_status'
      }
    """
    When method POST
    Then status 405
    And match response == null
  
  Scenario Outline: Test adding pets with different valid combinations of attributes
    Given path 'v2/pet'
    And request <payload>
    When method POST
    Then status 200
    And match response.id == '#number'
    And match response.category.id == '#? _ == null || typeof _ == "number"'
    And match response.category.name == '#? _ == null || typeof _ == "string"'
    And match response.name == '#string'
    And match response.photoUrls == '#array'
    And match each response.photoUrls[*] == '#string'
    And match response.tags == '#array'
    And match each response.tags[*].id == '#number'
    And match each response.tags[*].name == '#string'
    And match response.status == '#string'

    Examples:
      | payload                                                                                                     |
      | """ { id: 12346, category: { id: 2, name: 'Reptiles' }, name: 'lizard', photoUrls: ['https://example.com/photo.jpg'], tags: [], status: 'available' } """ |
      | """ { id: 12347, category: null, name: 'birdie', photoUrls: ['https://example.com/pic1.jpg', 'https://example.com/pic2.jpg'], tags: [{ id: 30, name: 'tag3' }], status: 'pending' } """ |
      | """ { id: 12348, category: { id: 3, name: 'Amphibians' }, name: 'froggie', photoUrls: [], tags: [], status: 'sold' } """                                |

  Scenario: Test response headers
    Given path 'v2/pet'
    And request """ 
      {
        id: 12349,
        category: { id: 4, name: 'Insects' },
        name: 'bee',
        photoUrls: ['https://example.com/bee.jpg'],
        tags: [],
        status: 'pending'
      }
    """
    When method POST
    Then status 200
    And match responseHeaders['Content-Type'] == 'application/json'

  Scenario: Test with missing required fields
    Given path 'v2/pet'
    And request """ 
      {
        id: 12350,
        name: 'missingPhotoUrls',
        status: 'available'
      }
    """
    When method POST
    Then status 405
    And match response == null
